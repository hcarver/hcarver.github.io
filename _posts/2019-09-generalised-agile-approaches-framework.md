---
layout: post
title: 'Generalised Agile Approaches Framework'
date: 2019-01-15
status: draft
type: post
published: true
author: Hywel Carver
---

Two recent realisations have inspired this post, which will turn into a summary of different ways
to lead your team in an Agile fashion. I'm also going to attempt to explain how you choose between them.
I'm going to call this approach the Generalised Agile Approaches Framework. It's a grab-bag of ideas
that already exist and get used (Generalised), it's about aligning with the Agile principles (Agile),
it's a plug-and-play set of processes to combine (Approaches) and I'll try to explain how I'd choose
between them (Framework).

### Inspiration

I keep seeing posts where someone writes that Agile is dead, or that it has failed. Reading the posts,
it then turns out that the real story is that a team used to do Scrum, called it Agile, and doesn't do
Scrum anymore.

The other day, I had a conversation with someone about different frameworks, and which one I favoured.
At some point, I threw up my hands and said no-one should ever do what a framework says, they should
pick and choose and adjust from different frameworks until they find something that works for the
context of the team they're working with.

That will sound obvious to some readers, and will sound like heresy to others. Most people would agree
there's no one correct framework for every situation, but I think the point is more general than that:
each framework is a fixed set of decisions, but lots of other combinations are possible. Each framework
is a single landmark on a map, but the right way of working for your team might be a different point on
the map which doesn't have a landmark.

### Frameworks

For my purposes, framework means a set of guidelines or processes for running delivery within a single software team.

That doesn't include Safe, Feature Teams, or Spotify's Tribes and Squads model, which are really about organising the teams themselves.

And it doesn't include practices like code review, pairing or test-driven-development, which are really about managing code quality, not how the code is delivered.

Here's a TL;DR version of each framework I'm considering, and how they manage different aspects of software delivery with ceremonies / events and artefacts.

*Scrum*

* Cadence: one *sprint*, typically one week or two weeks
* Teams: self-organising and cross-functional
* A retrospective meeting once a sprint (to reflect and improve the process)
* Planned work is specified on a product backlog
* A planning meeting once a sprint to estimate the effort required for each planned work unit, and create a list of tasks to be completed during the sprint
* The scope of work should be considered fixed during the sprint
* Daily scrum / stand-ups to confirm the sprint is on track for its target
* A review meeting at the end of a sprint to present completed work.
* Product owner represents the user / stakeholders
* Result: an incremental improvement to the product which can be shipped

*XP*

* Release plans are broken down into iteration plans, whose size is estimated
* Iterate your plans as they become outdated
* Small, continuous releases
* One individual represents the user / stakeholders
* Team starts each day with a stand up meeting, communicate problems & solutions
* Hold retrospective meetings to improve the process


Waterfall, Kanban, Scrumban, Crystal, Lean, DSDM, FDD


Factors:
Team size
Team maturity / discipline
Volatility in requirements
Transparency of requirements

